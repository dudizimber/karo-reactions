name: Build and Publish Docker Images

on:
  push:
    branches:
      - main
    tags:
      - 'release/*/*'  # Match release/<action-name>/<version>
    paths:
      - 'actions/*/Dockerfile'
      - 'actions/*/src/**'
      - '.github/workflows/docker-build.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'actions/*/Dockerfile'
      - 'actions/*/src/**'

env:
  REGISTRY: docker.io
  REGISTRY_USERNAME: dudizimber

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      actions_json: ${{ steps.changes.outputs.actions_json }}
      is_release: ${{ steps.release-info.outputs.is_release }}
      release_action: ${{ steps.release-info.outputs.action }}
      release_version: ${{ steps.release-info.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse release information
        id: release-info
        run: |
          if [[ "${{ github.ref_type }}" == "tag" && "${{ github.ref_name }}" =~ ^release/([^/]+)/(.+)$ ]]; then
            ACTION_NAME="${BASH_REMATCH[1]}"
            VERSION="${BASH_REMATCH[2]}"
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "action=$ACTION_NAME" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "Release detected for action: $ACTION_NAME, version: $VERSION"
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "Not a release tag"
          fi

      - name: Detect changed actions
        id: changes
        run: |
          if [ "${{ steps.release-info.outputs.is_release }}" == "true" ]; then
            # For releases, only build the specific action being released
            ACTION_NAME="${{ steps.release-info.outputs.action }}"
            if [ -f "actions/$ACTION_NAME/Dockerfile" ]; then
              ACTIONS_JSON="[\"actions/$ACTION_NAME\"]"
              echo "Building release for action: $ACTION_NAME"
            else
              echo "Error: No Dockerfile found for action $ACTION_NAME"
              exit 1
            fi
          else
            # For regular pushes/PRs, detect changed actions
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            else
              BASE_SHA="${{ github.event.before }}"
            fi

            # Find all action directories with Dockerfiles
            ALL_ACTIONS=$(find actions -name "Dockerfile" -exec dirname {} \; | sort)
            
            # Detect changed actions
            CHANGED_ACTIONS=""
            for action_dir in $ALL_ACTIONS; do
              if git diff --name-only $BASE_SHA HEAD | grep -q "^$action_dir/"; then
                CHANGED_ACTIONS="$CHANGED_ACTIONS $action_dir"
              fi
            done

            # Convert to JSON array for matrix
            ACTIONS_JSON=$(echo $CHANGED_ACTIONS | tr ' ' '\n' | grep -v '^$' | jq -R -s -c 'split("\n") | map(select(length > 0))')
            
            echo "Changed actions: $CHANGED_ACTIONS"
          fi
          
          echo "actions_json=$ACTIONS_JSON" >> $GITHUB_OUTPUT
          echo "Actions JSON: $ACTIONS_JSON"

  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.actions_json != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    strategy:
      matrix:
        action: ${{ fromJson(needs.detect-changes.outputs.actions_json) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract action name
        id: action
        run: |
          ACTION_NAME=$(basename "${{ matrix.action }}")
          echo "name=$ACTION_NAME" >> $GITHUB_OUTPUT
          echo "path=${{ matrix.action }}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Generate image tags and metadata
        id: meta
        run: |
          ACTION_NAME="${{ steps.action.outputs.name }}"
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.REGISTRY_USERNAME }}/karo-reactions-$ACTION_NAME"
          
          if [ "${{ needs.detect-changes.outputs.is_release }}" == "true" ] && [ "$ACTION_NAME" == "${{ needs.detect-changes.outputs.release_action }}" ]; then
            # Release build - use semantic versioning
            VERSION="${{ needs.detect-changes.outputs.release_version }}"
            # Parse semantic version parts
            if [[ $VERSION =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
              TAGS="$IMAGE_NAME:v$MAJOR.$MINOR.$PATCH,$IMAGE_NAME:v$MAJOR.$MINOR,$IMAGE_NAME:v$MAJOR,$IMAGE_NAME:latest"
            else
              # Non-semantic version
              TAGS="$IMAGE_NAME:$VERSION,$IMAGE_NAME:latest"
            fi
            echo "Release build for $ACTION_NAME version $VERSION"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # PR build
            PR_NUMBER="${{ github.event.number }}"
            TAGS="$IMAGE_NAME:pr-$PR_NUMBER"
            echo "PR build for $ACTION_NAME"
          else
            # Development build
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            TAGS="$IMAGE_NAME:main,$IMAGE_NAME:main-$SHORT_SHA"
            echo "Development build for $ACTION_NAME"
          fi
          
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.action.outputs.path }}
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.title=Karo - ${{ steps.action.outputs.name }}
            org.opencontainers.image.description=Action for Karo (Kubernetes Alert Reaction Operator)
            org.opencontainers.image.source=https://github.com/dudizimber/karo-reactions
            org.opencontainers.image.version=${{ needs.detect-changes.outputs.release_version || 'main' }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract first image tag
        id: first_image
        run: |
          echo "first_tag=$(echo '${{ steps.meta.outputs.tags }}' | cut -d',' -f1)" >> $GITHUB_OUTPUT

      - name: Run security scan
        if: github.event_name != 'pull_request'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.first_image.outputs.first_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        if: github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  discover-all-actions:
    runs-on: ubuntu-latest
    outputs:
      all_actions_json: ${{ steps.discover.outputs.all_actions_json }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Discover all actions
        id: discover
        run: |
          # Find all action directories (any directory under actions/)
          ALL_ACTIONS=$(find actions -maxdepth 1 -type d | grep -v '^actions$' | sort)
          
          # Convert to JSON array for matrix
          ALL_ACTIONS_JSON=$(echo $ALL_ACTIONS | tr ' ' '\n' | grep -v '^$' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          echo "all_actions_json=$ALL_ACTIONS_JSON" >> $GITHUB_OUTPUT
          echo "All actions: $ALL_ACTIONS"
          echo "Actions JSON: $ALL_ACTIONS_JSON"

  test-actions:
    needs: discover-all-actions
    if: needs.discover-all-actions.outputs.all_actions_json != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        action: ${{ fromJson(needs.discover-all-actions.outputs.all_actions_json) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract action name
        id: action
        run: |
          ACTION_NAME=$(basename "${{ matrix.action }}")
          echo "name=$ACTION_NAME" >> $GITHUB_OUTPUT
          echo "path=${{ matrix.action }}" >> $GITHUB_OUTPUT

      - name: Determine action type
        id: action-type
        run: |
          if [ -f "${{ steps.action.outputs.path }}/Dockerfile" ]; then
            echo "type=docker" >> $GITHUB_OUTPUT
            echo "Action ${{ steps.action.outputs.name }} is Docker-based"
          else
            echo "type=shell" >> $GITHUB_OUTPUT
            echo "Action ${{ steps.action.outputs.name }} is shell-based"
          fi

      - name: Set up Docker Buildx
        if: steps.action-type.outputs.type == 'docker'
        uses: docker/setup-buildx-action@v3

      - name: Build test image
        if: steps.action-type.outputs.type == 'docker'
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.action.outputs.path }}
          load: true
          tags: test-${{ steps.action.outputs.name }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Test Docker-based action
        if: steps.action-type.outputs.type == 'docker'
        run: |
          echo "Running tests for Docker action: ${{ steps.action.outputs.name }}"
          
          # Check if test.sh exists
          if [ -f "${{ steps.action.outputs.path }}/test.sh" ]; then
            echo "Found test.sh, running action-specific tests..."
            cd "${{ steps.action.outputs.path }}"
            chmod +x test.sh
            
            # Run the test script with the built image name as parameter
            ./test.sh "test-${{ steps.action.outputs.name }}:latest"
          else
            echo "No test.sh found, running basic smoke test..."
            # Basic smoke test - ensure container starts and exits successfully
            docker run --rm \
              -e WEBHOOK_URL="https://httpbin.org/post" \
              -e ALERT_JSON='{"status":"firing","labels":{"alertname":"TestAlert","severity":"warning"},"annotations":{"summary":"Test alert"}}' \
              test-${{ steps.action.outputs.name }}:latest || echo "Docker action test completed"
          fi

      - name: Test shell-based action
        if: steps.action-type.outputs.type == 'shell'
        run: |
          echo "Testing shell-based action: ${{ steps.action.outputs.name }}"
          
          # Check if test.sh exists
          if [ -f "${{ steps.action.outputs.path }}/test.sh" ]; then
            echo "Found test.sh, running action-specific tests..."
            cd "${{ steps.action.outputs.path }}"
            chmod +x test.sh
            
            # Run the test script (shell actions don't need image parameter)
            ./test.sh
          else
            echo "No test.sh found, running validation checks..."
            
            # Check required files exist
            if [ ! -f "${{ steps.action.outputs.path }}/README.md" ]; then
              echo "❌ Missing README.md"
              exit 1
            fi
            
            # Validate README.md contains required sections
            README_PATH="${{ steps.action.outputs.path }}/README.md"
            
            if ! grep -q "# " "$README_PATH"; then
              echo "❌ README.md missing main title"
              exit 1
            fi
            
            if ! grep -q -i "usage\|example" "$README_PATH"; then
              echo "❌ README.md missing usage/example section"
              exit 1
            fi
            
            # Check if action.yaml exists (optional)
            if [ -f "${{ steps.action.outputs.path }}/action.yaml" ]; then
              echo "✅ Found action.yaml specification"
              
              # Basic YAML syntax validation
              if command -v python3 >/dev/null 2>&1; then
                python3 -c "import yaml; yaml.safe_load(open('${{ steps.action.outputs.path }}/action.yaml'))" || {
                  echo "❌ Invalid YAML syntax in action.yaml"
                  exit 1
                }
                echo "✅ action.yaml has valid YAML syntax"
              fi
            fi
            
            echo "✅ Shell-based action validation passed"
          fi
